# Syndicate JSON Canvas

Goal: to allow a user to take a [JSON canvas file](https://jsoncanvas.org/spec/1.0/) (for example, created via Obsidian) and syndicate the contents to Twitter, a microblog or another sink. Each node in the JSON canvas can be mapped to a blog

There are a few features:
1. It should be designed as libraries and binary that can be run do the syndication end to end. The libraries should contain the important logic, while the binary source should merely string them together; effectively the binary source is just a configuration that defines the sources / sinks for the content.
2. The library should enable watching the file and running the syndication steps as needed.
3. The library should decompose into two parts: two part that parses, filters, and enriches the nodes in the jsoncanvas file (call this the backend), and the part that actually makes the edits to the syndication syncs (call this the frontend)
4. To begin with, we will not handle updating or deleting, only creating/publishing to syndication sinks.
5. However, we must ensure we don't duplicately publish something. To ensure this, we should maintain a set of jsoncanvas `NodeId`s in memory (and synced to disk for persistence). This should be read.

## Backend functionality

### Current

1. Critically, the backend should allow filtering the nodes. Currently the default filter just checks that the node is a `TextNode`, has a non-empty `text` field, and is colored red before publishing it
2. The backend should return a **HashMap/mapping from NodeId to SyndicationFormat**, not a Vec. This allows looking up nodes by ID when building references.
3. The backend should **detect cycles** in the graph:
   - Use topological sort to detect cycles
   - If a cycle is detected, print an error
   - Add a special node to the canvas alerting the user about the cycle (place it in the center of the canvas)
4. Each `SyndicationFormat` should now include:
   - `in_neighbor_ids: Vec<NodeId>` - nodes that point TO this node
   - `out_neighbor_ids: Vec<NodeId>` - nodes that this node points TO
   - This enables creating links between related posts

## Code structuring

1. Each piece of content to be syndicated should be coerced to the `SyndicationFormat` type. This is a type shared between the backend the frontend.

2. **IMPORTANT: Simplify lifetimes in SyndicationFormat**. Instead of storing references with lifetimes, store NodeIds and EdgeIds. These are cheap to clone and can be converted to CoW strings when needed. This avoids complex lifetime issues and makes the code much simpler.

3. **SyndicationFormat structure:**
```rust
struct SyndicationFormat {
    id: NodeId,
    text: String,
    in_neighbor_ids: Vec<NodeId>,   // nodes that point TO this node
    out_neighbor_ids: Vec<NodeId>,  // nodes that this node points TO
}
```

4. A syndication sink should be a trait:

```rust
trait SyndicationSink {
  fn publish(&mut self, items: &HashMap<NodeId, SyndicationFormat>, dry_run: bool) -> Result<(), SinkError>;
  fn name(&self) -> &str;
}
```

**IMPORTANT:** The `publish` method now takes ALL items at once (as a HashMap), not one at a time. This is necessary because:
- We need to compute slugs for all nodes to create proper cross-references
- Links between posts require knowing about all nodes simultaneously
- Different sinks may need to process items in specific orders

The trait should support a **dry-run mode** where `dry_run: bool` determines whether to actually perform the syndication or just log what would happen. This is useful for testing and validation.

5. We need a new library crate for the frontend. This crate should define the relevant trait, but also provide an implementation for Twitter and for git commiting + pushing files to a repository (by taking a path to the repository on disk)

## Deduplication Tracking

**NOTE: This is only relevant for Twitter/X syndication, not for the JJ repository sink.** The JJ sink does NOT use deduplication - it's acceptable to redo work since git history tracks everything naturally.

For Twitter/X and similar sinks where duplicate publishing is problematic, we need to track which NodeIds have already been published to each sink.

**Implementation requirements:**

1. **Format:** Use TOML files to persist the published NodeIds
2. **File location and naming:**
   - Tracking files should be located in the same directory as the canvas file
   - File naming pattern: `.<canvas-name>.canvas.syndication.<sink-name>.toml`
   - Example: For canvas file `my-notes.canvas` and JJ sink, the tracker would be `.my-notes.canvas.syndication.jj.toml`
   - These are hidden files (start with `.`) to keep the directory clean
   - Include a header comment: `# Generated by syndicate-json-canvas - Do not edit manually`
   - Store NodeIds as an array of strings
3. **Responsibility:** Persistence to disk is an **implementation detail of the binary**, not the libraries
4. **API Design:** The published NodeIds set should be both an input AND output:
   - Binary loads the set from disk before processing
   - Binary passes the set to the processing/publishing logic
   - Logic checks against the set before publishing
   - Logic returns an updated set after publishing
   - Binary persists the updated set back to disk
5. **One set per sink:** Each syndication sink maintains its own independent set of published NodeIds

**Example TOML structure:**
```toml
# Generated by syndicate-json-canvas - Do not edit manually

published_node_ids = [
  "node-abc123",
  "node-def456",
  "node-ghi789",
]
```

## Libraries to use

1. For now, remove the dependence on clap. The expectation should be that the user hard codes the path to the jsoncanvas (`.canvas`) file.
2. Keep using notify, but add debouncing: https://docs.rs/notify-debouncer-mini/latest/notify_debouncer_mini/ - read this file.
3. Keep using the jsoncanvas crate
4. **Use `thiserror` for error handling in the library crate**. Define a proper `SyndicationError` type instead of using `Box<dyn Error>`. 

## JJ Repository Sink

* Implement a sink that allows you to push to a jujutsu repository
* **IMPORTANT: No deduplication tracking.** It's acceptable to redo work - just rewrite all files each time. Git history naturally tracks changes.

In order to fully define a commit and push flow in jj, we need a few things

1. The bookmark name to update (default to main)
2. The name of the remote to push to (default to origin)
3. The path of the folder within a repository to put files in
4. Commit message - should be 'Adding microblog `<slug>`\n\n<First 50 chars of content>'. Use the first 8 words of the post for the slug.
5. The name of the file to use - should be the slug above appended with the NodeId
6. The contents of the file - This should have:
   - Frontmatter with:
     - `title`: First 8 words of the post (readable, not dasherized)
     - `date`: Current date in YYYY-MM-DD format
     - `context_for_this`: List of slugs for in-neighbor nodes (nodes that point TO this node), prefixed with '/t/'
     - `further_thinking`: List of slugs for out-neighbor nodes (nodes this node points TO), prefixed with '/t/'
   - Body: The full text content (no footer links needed - they will be inferred from frontmatter)

**Implementation notes:**
- Must pre-compute slugs for ALL nodes before generating any files (needed for cross-references)
- Process all items in a single publish call (the trait signature supports this)
- Each file should link to its related posts using their computed slugs

The first 3 should be required configuration options (ie members of the struct we use to implement SyndicationSink). The latter 3 should be done appropriately by our setup.

Analogous JJ setup
```sh
jj git fetch # always run to refresh
jj new --insert-after <bookmark name> -m <message> # this creates a new revision with the message
# write out all the files as needed
jj b m <bookmark name>
jj git push --remote <remote name> --bookmark <bookmark name>
```


## Committing using Jujutsu (a git compatible VCS)

The is a jujutsu (`jj`) repository: https://docs.jj-vcs.dev/latest/cli-reference/

Break your changes into bitesized pieces (they should mostly do one thing) as jj revisions. Run `jj show` to see your changes in the current revision. Run `jj describe -m <your commit message>` once your done with a revision and `jj new` to create a new one on top

Occassionally I will ask you to try a different approach. In this case, I will typically run `jj new` from an older commit, so that you will not have the previous approach on hand.

## DO THIS STUFF

1. First, I want you to fix the errors (there are a bunch of them).
2. Explore the project.
3. Next (or maybe concurrently with the first thing), think about what improvements can be made to the current design. Tell me about them!
4. Implement the other stuff
