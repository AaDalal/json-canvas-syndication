use std::collections::HashSet;
use std::error::Error;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use std::time::Duration;

use notify_debouncer_mini::{DebouncedEventKind, new_debouncer, notify::RecursiveMode};
use serde::{Deserialize, Serialize};
use syndicate_json_canvas_lib::jsoncanvas::{JsonCanvas, NodeId};
use syndicate_json_canvas_lib::{default_process_node, to_syndication_format};
use syndicate_json_canvas_sinks::{JjRepositorySink, SyndicationSink};
use tracing::{debug, error, info};
use tracing_subscriber::EnvFilter;

// Configuration: Update this path to point to your JSON Canvas file
const CANVAS_FILE_PATH: &str = "canvas.canvas";

// Debounce duration in milliseconds - waits this long after last change before processing
const DEBOUNCE_DURATION_MS: u64 = 500;

// Set to true to see what would happen without actually publishing
const DRY_RUN: bool = true;

// JJ Repository Sink Configuration
struct JjSinkConfig {
    repo_path: &'static str,
    bookmark_name: &'static str,
    remote_name: &'static str,
    folder_path: &'static str,
}

const JJ_SINK_CONFIG: JjSinkConfig = JjSinkConfig {
    repo_path: "/path/to/your/jj/repo",
    bookmark_name: "main",
    remote_name: "origin",
    folder_path: "microblog",
};

/// Tracks which NodeIds have been published to prevent duplicates
#[derive(Debug, Serialize, Deserialize)]
struct PublishedTracker {
    published_node_ids: HashSet<String>,
}

impl PublishedTracker {
    /// Load the tracker from a TOML file, or create a new empty tracker if file doesn't exist
    fn load(path: &Path) -> Result<Self, Box<dyn Error>> {
        if path.exists() {
            let content = std::fs::read_to_string(path)?;
            let tracker: PublishedTracker = toml::from_str(&content)?;
            Ok(tracker)
        } else {
            Ok(PublishedTracker {
                published_node_ids: HashSet::new(),
            })
        }
    }

    /// Save the tracker to a TOML file with header comment
    fn save(&self, path: &Path) -> Result<(), Box<dyn Error>> {
        let toml_content = toml::to_string_pretty(self)?;
        let content_with_header = format!(
            "# Generated by syndicate-json-canvas - Do not edit manually\n\n{}",
            toml_content
        );
        std::fs::write(path, content_with_header)?;
        Ok(())
    }

    /// Check if a NodeId has already been published
    fn is_published(&self, node_id: &NodeId) -> bool {
        self.published_node_ids.contains(&node_id.to_string())
    }

    /// Mark a NodeId as published
    fn mark_published(&mut self, node_id: &NodeId) {
        self.published_node_ids.insert(node_id.to_string());
    }
}

/// Generate the tracker file path for a given canvas file and sink name
/// Pattern: .<canvas-name>.canvas.syndication.<sink-name>.toml
/// Located in the same directory as the canvas file
fn get_tracker_path(canvas_path: &Path, sink_name: &str) -> Result<PathBuf, Box<dyn Error>> {
    let parent = canvas_path.parent()
        .ok_or("Canvas path must have a parent directory")?;

    let canvas_filename = canvas_path.file_name()
        .ok_or("Canvas path must have a filename")?
        .to_str()
        .ok_or("Canvas filename must be valid UTF-8")?;

    // Generate the tracker filename: .<canvas-name>.canvas.syndication.<sink-name>.toml
    let tracker_filename = format!(".{}.syndication.{}.toml", canvas_filename, sink_name);

    Ok(parent.join(tracker_filename))
}

fn validate_canvas_path(path: &Path) -> Result<(), &str> {
    if !path.is_file() {
        return Err("Provided path must be a file");
    }
    if path.extension().and_then(|s| s.to_str()) != Some("canvas") {
        return Err("Expect the extension to be .canvas");
    }
    Ok(())
}

/// Watch the canvas file and process changes
fn watch_and_process(
    canvas_path: &Path,
    mut sink: impl SyndicationSink,
    tracker_path: &Path,
    mut tracker: PublishedTracker,
    dry_run: bool,
) -> Result<(), Box<dyn Error>> {
    let (tx, rx) = std::sync::mpsc::channel();
    let mut debouncer = new_debouncer(Duration::from_millis(DEBOUNCE_DURATION_MS), tx)?;

    debouncer
        .watcher()
        .watch(canvas_path, RecursiveMode::NonRecursive)?;

    for res in rx {
        match res {
            Ok(events) => {
                for event in events {
                    if let DebouncedEventKind::Any = event.kind {
                        info!("File changed, processing...");

                        let content = match std::fs::read_to_string(canvas_path) {
                            Ok(c) => c,
                            Err(e) => {
                                error!(error = %e, "Failed to read file");
                                continue;
                            }
                        };

                        let canvas = match JsonCanvas::from_str(&content) {
                            Ok(c) => c,
                            Err(e) => {
                                error!(error = %e, "Failed to parse canvas");
                                continue;
                            }
                        };

                        let syndication_items = to_syndication_format(canvas, Some(default_process_node));
                        debug!(items_count = syndication_items.len(), "Found items to syndicate");

                        let new_items: Vec<_> = syndication_items
                            .iter()
                            .filter(|item| !tracker.is_published(&item.id))
                            .collect();

                        info!(
                            new_items = new_items.len(),
                            already_published = syndication_items.len() - new_items.len(),
                            "Filtered items"
                        );

                        let mut published_count = 0;
                        for item in &new_items {
                            match sink.publish(item, dry_run) {
                                Ok(()) => {
                                    info!(node_id = %item.id, "Published item");
                                    tracker.mark_published(&item.id);
                                    published_count += 1;
                                }
                                Err(e) => error!(node_id = %item.id, error = %e, "Failed to publish item"),
                            }
                        }

                        if published_count > 0 {
                            match tracker.save(tracker_path) {
                                Ok(()) => info!(
                                    total_published = tracker.published_node_ids.len(),
                                    "Saved tracker"
                                ),
                                Err(e) => error!(error = %e, "Failed to save tracker"),
                            }
                        }
                    }
                }
            }
            Err(error) => error!(error = ?error, "Watch error"),
        }
    }

    Ok(())
}

fn main() -> Result<(), Box<(dyn Error)>> {
    // Initialize logging (DEBUG when dry-run, INFO otherwise)
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::new(if DRY_RUN { "debug" } else { "info" }))
        .with_line_number(true)
        .with_file(true)
        .with_target(false)
        .init();

    // Setup canvas file path
    let canvas_path = PathBuf::from(CANVAS_FILE_PATH);
    validate_canvas_path(&canvas_path)?;

    // Setup syndication sink
    let jj_sink = JjRepositorySink::new(
        JJ_SINK_CONFIG.repo_path,
        JJ_SINK_CONFIG.bookmark_name,
        JJ_SINK_CONFIG.remote_name,
        JJ_SINK_CONFIG.folder_path,
    )?;

    // Setup deduplication tracker
    let tracker_path = get_tracker_path(&canvas_path, "jj")?;
    let jj_tracker = PublishedTracker::load(&tracker_path)?;

    // Log configuration
    info!(
        canvas_file = %canvas_path.display(),
        debounce_ms = DEBOUNCE_DURATION_MS,
        "Watching canvas file"
    );
    info!(sink = jj_sink.name(), dry_run = DRY_RUN, "Publishing configuration");
    info!(tracker_file = %tracker_path.display(), "Tracker file location");
    info!(
        previously_published = jj_tracker.published_node_ids.len(),
        "Loaded published tracker"
    );

    // Start watching and processing
    watch_and_process(&canvas_path, jj_sink, &tracker_path, jj_tracker, DRY_RUN)
}
