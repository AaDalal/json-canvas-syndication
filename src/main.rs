use std::error::Error;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use std::time::Duration;

use notify_debouncer_mini::{DebouncedEventKind, new_debouncer, notify::RecursiveMode};
use serde::{Deserialize, Serialize};
use syndicate_json_canvas_lib::jsoncanvas::{JsonCanvas, NodeId};
use syndicate_json_canvas_lib::{default_process_node, to_syndication_format};
use syndicate_json_canvas_sinks::{JjRepositorySink, SyndicationSink};
use tracing::{debug, error, info};
use tracing_subscriber::EnvFilter;

// Configuration: Update this path to point to your JSON Canvas file
const CANVAS_FILE_PATH: &str = "canvas.canvas";

// Debounce duration in milliseconds - waits this long after last change before processing
const DEBOUNCE_DURATION_MS: u64 = 500;

// JJ Repository Sink Configuration
const JJ_REPO_PATH: &str = "/path/to/your/jj/repo";
const JJ_BOOKMARK_NAME: &str = "main";
const JJ_REMOTE_NAME: &str = "origin";
const JJ_FOLDER_PATH: &str = "microblog";

// Set to true to see what would happen without actually publishing
const DRY_RUN: bool = true;

/// Tracks which NodeIds have been published to prevent duplicates
#[derive(Debug, Serialize, Deserialize)]
struct PublishedTracker {
    published_node_ids: Vec<String>,
}

impl PublishedTracker {
    /// Load the tracker from a TOML file, or create a new empty tracker if file doesn't exist
    fn load(path: &Path) -> Result<Self, Box<dyn Error>> {
        if path.exists() {
            let content = std::fs::read_to_string(path)?;
            let tracker: PublishedTracker = toml::from_str(&content)?;
            Ok(tracker)
        } else {
            Ok(PublishedTracker {
                published_node_ids: Vec::new(),
            })
        }
    }

    /// Save the tracker to a TOML file with header comment
    fn save(&self, path: &Path) -> Result<(), Box<dyn Error>> {
        let toml_content = toml::to_string_pretty(self)?;
        let content_with_header = format!(
            "# Generated by syndicate-json-canvas - Do not edit manually\n\n{}",
            toml_content
        );
        std::fs::write(path, content_with_header)?;
        Ok(())
    }

    /// Check if a NodeId has already been published
    fn is_published(&self, node_id: &NodeId) -> bool {
        self.published_node_ids.contains(&node_id.to_string())
    }

    /// Mark a NodeId as published
    fn mark_published(&mut self, node_id: &NodeId) {
        let node_id_str = node_id.to_string();
        if !self.published_node_ids.contains(&node_id_str) {
            self.published_node_ids.push(node_id_str);
        }
    }
}

/// Generate the tracker file path for a given canvas file and sink name
/// Pattern: .<canvas-name>.canvas.syndication.<sink-name>.toml
/// Located in the same directory as the canvas file
fn get_tracker_path(canvas_path: &Path, sink_name: &str) -> Result<PathBuf, Box<dyn Error>> {
    let parent = canvas_path.parent()
        .ok_or("Canvas path must have a parent directory")?;

    let canvas_filename = canvas_path.file_name()
        .ok_or("Canvas path must have a filename")?
        .to_str()
        .ok_or("Canvas filename must be valid UTF-8")?;

    // Generate the tracker filename: .<canvas-name>.canvas.syndication.<sink-name>.toml
    let tracker_filename = format!(".{}.syndication.{}.toml", canvas_filename, sink_name);

    Ok(parent.join(tracker_filename))
}

fn validate_canvas_path(path: &Path) -> Result<(), &str> {
    if !path.is_file() {
        return Err("Provided path must be a file");
    }
    if path.extension().and_then(|s| s.to_str()) != Some("canvas") {
        return Err("Expect the extension to be .canvas");
    }
    Ok(())
}

fn main() -> Result<(), Box<(dyn Error)>> {
    // Initialize tracing subscriber with line numbers
    // Use DEBUG level when dry_run is true, otherwise INFO
    let log_level = if DRY_RUN { "debug" } else { "info" };
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::new(log_level))
        .with_line_number(true)
        .with_file(true)
        .with_target(false)
        .init();

    let canvas_path = PathBuf::from(CANVAS_FILE_PATH);
    validate_canvas_path(&canvas_path)?;

    // Initialize JJ repository sink
    let mut jj_sink = JjRepositorySink::new(
        JJ_REPO_PATH,
        JJ_BOOKMARK_NAME,
        JJ_REMOTE_NAME,
        JJ_FOLDER_PATH,
    )?;

    // Generate tracker path based on canvas file and sink name
    let tracker_path = get_tracker_path(&canvas_path, "jj")?;
    let mut jj_tracker = PublishedTracker::load(&tracker_path)?;

    info!(
        canvas_file = %canvas_path.display(),
        debounce_ms = DEBOUNCE_DURATION_MS,
        "Watching canvas file"
    );
    info!(sink = jj_sink.name(), dry_run = DRY_RUN, "Publishing configuration");
    info!(tracker_file = %tracker_path.display(), "Tracker file location");
    info!(
        previously_published = jj_tracker.published_node_ids.len(),
        "Loaded published tracker"
    );

    let (tx, rx) = std::sync::mpsc::channel();

    // Create a debounced watcher
    let mut debouncer = new_debouncer(Duration::from_millis(DEBOUNCE_DURATION_MS), tx)?;

    debouncer
        .watcher()
        .watch(&canvas_path, RecursiveMode::NonRecursive)?;

    for res in rx {
        match res {
            Ok(events) => {
                // Process debounced events
                for event in events {
                    match event.kind {
                        DebouncedEventKind::Any => {
                            info!("File changed, processing...");
                            // Read the file and parse it
                            match std::fs::read_to_string(&canvas_path) {
                                Ok(content) => {
                                    match JsonCanvas::from_str(&content) {
                                        Ok(canvas) => {
                                            let syndication_items = to_syndication_format(
                                                canvas,
                                                Some(default_process_node),
                                            );
                                            debug!(
                                                items_count = syndication_items.len(),
                                                "Found items to syndicate"
                                            );

                                            // Filter out already-published items
                                            let new_items: Vec<_> = syndication_items
                                                .iter()
                                                .filter(|item| !jj_tracker.is_published(&item.id))
                                                .collect();

                                            info!(
                                                new_items = new_items.len(),
                                                already_published = syndication_items.len() - new_items.len(),
                                                "Filtered items"
                                            );

                                            // Publish each new item
                                            let mut published_count = 0;
                                            for item in &new_items {
                                                match jj_sink.publish(item, DRY_RUN) {
                                                    Ok(()) => {
                                                        info!(node_id = %item.id, "Published item");
                                                        // Mark as published
                                                        jj_tracker.mark_published(&item.id);
                                                        published_count += 1;
                                                    }
                                                    Err(e) => error!(
                                                        node_id = %item.id,
                                                        error = %e,
                                                        "Failed to publish item"
                                                    ),
                                                }
                                            }

                                            // Save tracker if we published anything
                                            if published_count > 0 {
                                                match jj_tracker.save(&tracker_path) {
                                                    Ok(()) => info!(
                                                        total_published = jj_tracker.published_node_ids.len(),
                                                        "Saved tracker"
                                                    ),
                                                    Err(e) => error!(error = %e, "Failed to save tracker"),
                                                }
                                            }
                                        }
                                        Err(e) => error!(error = %e, "Failed to parse canvas"),
                                    }
                                }
                                Err(e) => error!(error = %e, "Failed to read file"),
                            }
                        }
                        _ => {}
                    }
                }
            }
            Err(error) => {
                error!(error = ?error, "Watch error");
            }
        }
    }

    Ok(())
}
