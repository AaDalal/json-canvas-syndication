use crate::{SinkError, SyndicationSink};
use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use syndicate_json_canvas_lib::{SyndicationFormat, jsoncanvas::NodeId};
use tracing::{debug, info, warn};
use serde::{Deserialize, Serialize};

/// Configuration for Twitter/X syndication sink
pub struct TwitterSink {
    /// Twitter API Bearer Token
    bearer_token: String,
    /// Path to the tracker file for deduplication
    tracker_path: PathBuf,
    /// In-memory tracker of published node IDs
    published_ids: HashSet<String>,
}

/// Tracker for published tweets
#[derive(Debug, Serialize, Deserialize)]
struct TwitterTracker {
    published_node_ids: Vec<String>,
}

impl TwitterTracker {
    fn load(path: &Path) -> Result<Self, SinkError> {
        if path.exists() {
            let content = std::fs::read_to_string(path)?;
            let tracker: TwitterTracker = toml::from_str(&content)
                .map_err(|e| SinkError::Serialization(e.to_string()))?;
            Ok(tracker)
        } else {
            Ok(TwitterTracker {
                published_node_ids: Vec::new(),
            })
        }
    }

    fn save(&self, path: &Path) -> Result<(), SinkError> {
        let toml_content = toml::to_string_pretty(self)
            .map_err(|e| SinkError::Serialization(e.to_string()))?;
        let content_with_header = format!(
            "# Generated by syndicate-json-canvas - Do not edit manually\n\n{}",
            toml_content
        );
        std::fs::write(path, content_with_header)?;
        Ok(())
    }
}

impl TwitterSink {
    /// Create a new Twitter sink
    ///
    /// # Arguments
    /// * `bearer_token` - Twitter API v2 Bearer Token
    /// * `tracker_path` - Path to TOML file for tracking published tweets
    pub fn new(
        bearer_token: impl Into<String>,
        tracker_path: impl AsRef<Path>,
    ) -> Result<Self, SinkError> {
        let tracker_path = tracker_path.as_ref().to_path_buf();

        // Load existing tracker
        let tracker = TwitterTracker::load(&tracker_path)?;
        let published_ids: HashSet<String> = tracker.published_node_ids.into_iter().collect();

        Ok(Self {
            bearer_token: bearer_token.into(),
            tracker_path,
            published_ids,
        })
    }

    /// Check if a node has already been published
    fn is_published(&self, node_id: &NodeId) -> bool {
        self.published_ids.contains(node_id.as_str())
    }

    /// Mark a node as published
    fn mark_published(&mut self, node_id: &NodeId) {
        self.published_ids.insert(node_id.as_str().to_string());
    }

    /// Save the tracker to disk
    fn save_tracker(&self) -> Result<(), SinkError> {
        let tracker = TwitterTracker {
            published_node_ids: self.published_ids.iter().cloned().collect(),
        };
        tracker.save(&self.tracker_path)
    }

    /// Split text into tweet-sized chunks (280 characters, accounting for thread numbering)
    fn split_into_tweets(text: &str) -> Vec<String> {
        const MAX_TWEET_LENGTH: usize = 280;
        const THREAD_SUFFIX_LENGTH: usize = 10; // " (1/N)" plus safety margin

        let available_length = MAX_TWEET_LENGTH - THREAD_SUFFIX_LENGTH;

        // Simple word-boundary splitting
        let mut tweets = Vec::new();
        let mut current_tweet = String::new();

        for word in text.split_whitespace() {
            if current_tweet.len() + word.len() + 1 > available_length {
                if !current_tweet.is_empty() {
                    tweets.push(current_tweet.trim().to_string());
                    current_tweet = String::new();
                }
            }

            if !current_tweet.is_empty() {
                current_tweet.push(' ');
            }
            current_tweet.push_str(word);
        }

        if !current_tweet.is_empty() {
            tweets.push(current_tweet.trim().to_string());
        }

        // Add thread numbering if multiple tweets
        if tweets.len() > 1 {
            let total = tweets.len();
            tweets = tweets
                .into_iter()
                .enumerate()
                .map(|(i, tweet)| format!("{} ({}/{})", tweet, i + 1, total))
                .collect();
        }

        tweets
    }

    /// Post a tweet using Twitter API v2
    fn post_tweet(&self, text: &str, reply_to_id: Option<String>, dry_run: bool) -> Result<String, SinkError> {
        if dry_run {
            debug!(text = %text, reply_to = ?reply_to_id, "[DRY RUN] Would post tweet");
            // Return a fake tweet ID in dry run mode
            return Ok(format!("fake-tweet-id-{}", uuid::Uuid::new_v4()));
        }

        // Prepare the request body
        let mut body = serde_json::json!({
            "text": text
        });

        if let Some(reply_id) = reply_to_id {
            body["reply"] = serde_json::json!({
                "in_reply_to_tweet_id": reply_id
            });
        }

        // Make the API request
        let client = reqwest::blocking::Client::new();
        let response = client
            .post("https://api.twitter.com/2/tweets")
            .header("Authorization", format!("Bearer {}", self.bearer_token))
            .header("Content-Type", "application/json")
            .json(&body)
            .send()
            .map_err(|e| SinkError::CommandFailed(format!("Failed to post tweet: {}", e)))?;

        if !response.status().is_success() {
            let error_text = response.text().unwrap_or_else(|_| "Unknown error".to_string());
            return Err(SinkError::CommandFailed(format!(
                "Twitter API error: {}",
                error_text
            )));
        }

        let response_json: serde_json::Value = response
            .json()
            .map_err(|e| SinkError::CommandFailed(format!("Failed to parse response: {}", e)))?;

        // Extract the tweet ID from the response
        let tweet_id = response_json["data"]["id"]
            .as_str()
            .ok_or_else(|| SinkError::CommandFailed("No tweet ID in response".to_string()))?
            .to_string();

        info!(tweet_id = %tweet_id, "Posted tweet");
        Ok(tweet_id)
    }

    /// Publish a single item as a tweet or thread
    fn publish_item(&mut self, item: &SyndicationFormat, dry_run: bool) -> Result<(), SinkError> {
        if self.is_published(&item.id) {
            debug!(node_id = %item.id, "Already published, skipping");
            return Ok(());
        }

        info!(node_id = %item.id, "Publishing to Twitter");

        // Split into tweets if needed
        let tweets = Self::split_into_tweets(&item.text);

        if tweets.is_empty() {
            warn!(node_id = %item.id, "No content to tweet");
            return Ok(());
        }

        info!(tweet_count = tweets.len(), "Publishing as thread");

        // Post the first tweet
        let mut last_tweet_id = self.post_tweet(&tweets[0], None, dry_run)?;

        // Post remaining tweets as replies
        for tweet in &tweets[1..] {
            last_tweet_id = self.post_tweet(tweet, Some(last_tweet_id), dry_run)?;
        }

        // Mark as published
        self.mark_published(&item.id);

        Ok(())
    }
}

impl SyndicationSink for TwitterSink {
    fn publish(&mut self, items: &HashMap<NodeId, SyndicationFormat>, dry_run: bool) -> Result<(), SinkError> {
        info!(item_count = items.len(), "Publishing to Twitter");

        if items.is_empty() {
            info!("No items to publish");
            return Ok(());
        }

        // Filter out already published items
        let new_items: Vec<_> = items
            .values()
            .filter(|item| !self.is_published(&item.id))
            .collect();

        info!(
            new_items = new_items.len(),
            already_published = items.len() - new_items.len(),
            "Filtered items"
        );

        if new_items.is_empty() {
            info!("All items already published");
            return Ok(());
        }

        // Publish each new item
        let mut published_count = 0;
        for item in new_items {
            match self.publish_item(item, dry_run) {
                Ok(()) => {
                    info!(node_id = %item.id, "Published to Twitter");
                    published_count += 1;
                }
                Err(e) => {
                    // Log error but continue with other items
                    tracing::error!(node_id = %item.id, error = %e, "Failed to publish to Twitter");
                }
            }
        }

        // Save tracker if we published anything
        if published_count > 0 {
            self.save_tracker()?;
            info!(
                total_published = self.published_ids.len(),
                "Saved tracker"
            );
        }

        info!("Successfully published to Twitter");
        Ok(())
    }

    fn name(&self) -> &str {
        "twitter"
    }
}
